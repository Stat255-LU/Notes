# Interval Estimation

**Learning Outcomes:**     

1. State null and alternative hypotheses associated with models involving categorical and quantitative explanatory variables.   
2. Explain how to use permutation tests for hypotheses involving means, medians, F-statistics, slopes, and other regression coefficients, as well as functions of these statistics.   
3. Interpret p-values in context.    
4. Explain the conclusions we should draw from from a hypothesis test, while accounting for   other information available in a dataset.   
5. Explain how to simultaneously test for differences between multiple groups.    
6. Distinguish between statistical significance and practical importance.    


```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE, fig.height = 3, fig.width = 7, cache=TRUE)
library(ggformula)
library(moderndive)
library(gridExtra)
library(skimr)
library(Bolstad)
library(GGally)
library(Lock5Data)
library(knitr)
library(caret)
library(MASS)
library(tidyverse)
library(nycflights13)
options(scipen=999)
select <- dplyr::select
set.seed(07302020)
```

## Sampling Distributions

### Sampling From a Population

In statistics, we often do not have the time, money, or means to collect data on all individuals or units on which we want to draw conclusions. Instead, we might collect data on only a subset of the individuals, and then make inferences about all individuals we are interested in, using the information we collected. 


**Vocabulary:**      

1. A **population** is the entire set of individuals that we want to draw conclusions about. 
2. A **sample** is a subset of a population 
3. A **parameter** is a numerical quantity pertaining to an entire population     
4. A **statistic** is a numerical quantity calculated from a sample     


We'll work with a dataset containing information on all 20,591 flights from New York to Chicago in 2013. Our population of interest is all 20,591 flights. 

In this situation, we have information on the entire population, but suppose temporarily that we didn't. Instead, suppose we had only information on a random sample of 75 flights.

The parameter of interest is the proportion of on-time arrivals out of all flights in the population of 20,591. When the parameter is proportion, we'll denote it with the letter $p$. 

```{r, echo=FALSE}
data(flights)
Flights_NY_CHI <- flights %>% filter(dest %in% c("ORD", "MDW")) %>% filter(!is.na(arr_delay))
Flights_NY_CHI <- Flights_NY_CHI %>% mutate(ontime = ifelse(arr_delay <= 0, "Y", "N")) %>% select(year, month, day, carrier, origin, dest, sched_dep_time,arr_delay, ontime)
```

We take a sample of 75 flights. The first 6 flights in the sample are shown below. The `ontime` variable tells whether or not the flight arrived on time. 

```{r}
set.seed(08082023)
S1 <- sample_n(Flights_NY_CHI, 75)
head(S1)
```

We'll calculate the number, and proportion of flights that arrived on time. 

```{r}
num_ontime <- sum(S1$ontime == "Y") # count number of on-time arrivals
```

Number of on-time arrivals in the sample.

```{r}
num_ontime
```

Proportion of on-time arrivals in the sample.  

```{r}
p_hat <- num_ontime/75
p_hat
```

In out sample `r p_hat*100` percent of flights arrived on-time. We'll denote this quantity $\hat{p}$, keeping with our convention of using the $\hat{}$ symbol to represent a quantity that is calculated from data (like the predictions and estimates we saw in the previous chapter). The sample statistic $\hat{p}$ is an estimate of the population proportion $p$. 

Of course, this was just one sample of 75 flights. We should not expect the proportion of on-time flights in our sample ($\hat{p}$) to exactly match the proportion of on-time flights in the entire population ($p$). Nevertheless we can use the sample to estimate the proportion of all flights in the population that arrive on time. Perhaps, we could say that we would expect between `r p_hat*100 -10` and `r p_hat*100 +10` percent of all 2013 flights from New York to arrive on time. Or, perhaps we could be more precise and estimate that the percentage of on-time flights to be between `r p_hat*100 -5` and `r p_hat*100 + 5`. We'll need to figure out how precise we can make our range, while still being confident that it does, in fact, contain the true population parameter.   

To summarize: 

* The population is all 20,591 flights from New York to Chicago in 2013. 
* The sample is the flights that we randomly selected.   
* The parameter $p$ is the proportion of on-time arrivals among all 2013 flights from New York to Chicago, which we do not know (though in this particular example, we could find it, since we have data on all flights in the population.)        
* The sample statistic is the proportion of flights in our sample that arrived on time, which we know to be $\hat{p}$ = `r p_hat`. 

Now, let's take a different sample of 75 flights and see how the proportion of on-time arrivals compares. 

```{r}
S2 <- sample_n(Flights_NY_CHI, 75)
num_ontime2 <- sum(S2$ontime == "Y") # count number of on-time arrivals
p_hat2 <- num_ontime2/75
p_hat2
```

By studying the behavior of the proportion of on-time arrivals in different samples we can gauge how close the proportion in a given sample is likely be to the unknown population parameter. If all of our samples produce very similar estimates, then it is likely that the population parameter is close to these estimates. If the sample proportion varies considerably from sample to sample, then it is possible that the proportion in any given sample might be very different than the population parameter.   

Let's take 10,000 more random samples of 75 flights and record the proportion of on-time arrivals in each sample.   

```{r}
nreps <- 10000  # number of repetitions
p_hat_val <- rep(NA, nreps) # create vector to hold proportion of on-time arrivals
Sample <- 1:nreps

for(i in 1:nreps){
S <- sample_n(Flights_NY_CHI, 75) # take sample of 75
N_ontime <- sum(S$ontime == "Y") # count number of on-time arrivals
p_hat_val[i] <- N_ontime/75 # record proportion on-time
}

Samples_df <- data.frame(Sample, p_hat_val) # store results in a data frame
```

The table shows the proportion of on-time arrivals in the first 20 samples of 75 flights.  

```{r}
kable(head(Samples_df, 20))
```

The histogram below shows the distribution of the proportion of on-time arrivals in the 10,000 different samples.  

```{r}
Prop_Samp_Dist<- ggplot(data=Samples_df, aes(x=p_hat_val)) +
  geom_histogram(color="white", fill="blue") + 
  ggtitle("Sampling Distribution for Proportion On Time") + 
  xlab("Prop. on time in sample")
Prop_Samp_Dist
```

We notice that most of our 10,000 samples yielded proportions of on-time arrivals between 0.5 and 0.7, The distribution of proportion of on-time arrivals is roughly symmetric and bell-shaped. 

The distribution shown in this histogram is called  the **sampling distribution for $\hat{p}**. We can gauge how much the proportion of on-time arrivals varies between samples by calculating the standard deviation of this sampling distribution. The standard deviation of a sampling distribution for a statistic is also called the **standard error** of the statistic. In this case it represents the standard error $\hat{p}$ (the proportion of on-time arrivals), and is denoted $\text{SE}(\hat{p})$. This standard error is shown below.  

```{r}
SE_p_hat <- sd(Samples_df$p_hat_val)
SE_p_hat
```


**Vocabulary*:*    

* The **sampling distribution** of a statistic is the distribution of values the statistic takes on across many different samples of a given size.   
* The **standard error** of a statistic is the standard deviation of that statistic's sampling distribution. It measures how much the statistic varies between different samples of a given size.  

In this rare situation, we actually have data on all 20,591 flights from New York to Chicago in 2013 (our entire population), Let's calculate the true value of the population parameter $p$,  the proportion of flights that arrived on-time in our actual population. 

```{r}
p <- sum(Flights_NY_CHI$ontime == "Y")/20591
p
```

In fact, just over 60% of all flights in the population arrived on time. 

The sampling distribution for the proportion of on-time flights is shown again below. The true proportion of on-time flights is marked by the green dotted line. The gold bar at the bottom of the histogram represents the range of sample proportions that lie within $\pm 2$ standard errors of the true population proportion of flights that arrived on time. 

`r p` - 2(`r SE_p_hat`) to `r p` + 2(`r SE_p_hat`)

```{r}
Prop_Samp_Dist+ geom_vline(xintercept=p, color="green", linetype="dotted", linewidth=2) + geom_segment(aes(x=p - 2*SE_p_hat,xend=p + 2*SE_p_hat, y=50, yend=50), color="gold", size=10, alpha=0.01) 
```

We calculate the proportion of samples whose proportion of on-time arrivals lies within $\pm 2$ standard errors of the true proportion. 

```{r}
Lower <- p - 2*SE_p_hat
Upper <- p + 2*SE_p_hat
sum((Samples_df$p_hat_val >=Lower) & (Samples_df$p_hat_val <= Upper))
```

` r sum((Samples_df$p_hat >=Lower) & (Samples_df$p_hat <= Upper))` out of the 10,000 simulations (approximately 95%) of the samples produced proportions within $\pm 2$ standard errors of the true population proportion of on-time flights.   

### Confidence Intervals

In a real situation, we won't have access to the entire population of flights, only the flights in a single sample. For example, recall our original sample of 75 flights, in which we observed a proportion of on-time arrivals of $\hat{p}=$ `r p_hat`.

Since we now know that 95% of all samples produce proportions that lie within two standard errors of the population proportion, we can obtain an estimate of the population proportion $p$ by adding and subtracting $2\times \text{SE}(\hat{p})$ from our observed sample proportion $\hat{p}$. Such an interval is called an approximate 95% **confidence interval** for the true population proportion $p$.

**Approximate 95% Confidence Interval for $\hat{p}$**

\[
\hat{p} \pm 2\times \text{SE}(\hat{p})
\]

The confidence interval, based on our original sample, is calculated below. 

```{r}
c(p_hat - 2*SE_p_hat, p_hat + 2*SE_p_hat) 
```

Based on our sample of 75 flights, we can be 95% confident that the true proportion of on-time arrivals among all 2013 flights from New York to Chicago is between `r p_hat - 2*SE_p_hat` and `p_hat + 2*SE_p_hat`. 

In fact, knowing what we do about the true value of the population parameter $p$, we can see that our confidence interval does indeed contain this value. Of course, in a real situaiton, we won't know the true value of the population parameter, so we won't know for sure whether or not our confidence interval contains this true parameter value.   

A pertinent question at this stage would be ``What does 95% confidence mean?". To answer that, let's explore what happens when we calculate confidence intervals based on estimates many different samples. For each of our 10,000 different samples taken from our population, we'll add and subtract two standard errors from the sample proportion $\hat{p}$ corresponding to that sample. 

The table below displays the value of $\hat{p}$, for the first 20 samples we took, along with the lower and upper bounds of the confidence interval, and whether or not the confidence interval contains the true parameter value $p$ (either `TRUE` or `FALSE`). 

```{r}
Samples_df <- Samples_df %>% mutate( Lower = p_hat_val - 2*SE_p_hat, 
                                     Upper = p_hat_val + 2*SE_p_hat,
                                     Contains = p >= Lower & p <= Upper)
kable(head(Samples_df, 20))
```

The graphic below visualizes the confidence intervals produced using the estimates from the first 100 samples. The green dotted line indicates the true value of $p$. The black dots indicate the value of $\hat{p}$ for each sample. Intervals that do in fact  contain the true value of $p$  are shown in blue, and intervals that do not contain the true value of $p$ are shown in green.   

```{r, fig.height=15, fig.width=10}
ggplot(data=Samples_df[1:100,], aes(y=Sample, x=p_hat_val)) +    
  geom_point() +
  geom_errorbar(aes(xmin = Lower, xmax = Upper, color=Contains))  + 
  xlab("Confidence Interval") + 
  ylab("Sample") + 
  geom_vline(xintercept = p, color="green", linetype="dotted", size=2) + theme_bw()
```

Out of these 100 samples, `r sum(Samples_df$Contains[1:100]==TRUE)` contain the true value of the population parameter $p$. This is close to the 95% confidence level. 

The picture shows confidence intervals produced by the first 100 samples, but we actually took 10,000 different samples of 75 flights. Let's calculate how many of these samples produced confidence intervals that contain the true value of $p$. 

```{r}
sum(Samples_df$Contains == TRUE)
```

Again, notice that close to 95% of the samples produced confidence intervals contain the true population parameter $p$. Note that for the red intervals that do not contain $p$ nothing was done incorrectly. The sample was taken at random, and the confidence interval was calculated using the correct formula. It just happened that by chance, we obtained a sample proportion $\hat{p}$ that was unusually high or low, leading to an interval that did not capture the true population parameter. This, of course, happens rarely, and approximately 95% of the samples do, in fact, result in intervals that contain the true value of $p$. 

This brings us back to the question "what does 95% confidence mean?". An approximate 95% confidence interval means that if we take a large number of samples and calculate confidence intervals from each of them, then approximately 95% of the samples will produce intervals containing the true population parameter. In reality, we'll only have on sample, and won't know whether or not our interval contains the true parameter value. Assuming we have taken the sample and calculated the interval correctly, we can rest assured in the knowledge that that 95% of all intervals taken would contain the true parameter value, and hope that ours is among that 95%.     

We calculated the confidence interval by taking our sample statistic $\hat{p}$ plus/minus two standard errors. Confidence intervals that are calculated by adding and subtracting a certain number of standard errors from the sample statistic are called **standard error confidence intervals**. This approach will work as long as the sampling distribution is symmetric and bell-shaped. Probability theory tells us that in a symmetric and bell-shaped distribution, approximately 95% of the area lies within two standard errors of the center of the distribution, given by the true parameter value. We will, however, see that this approach will not work in all cases. Not all statistics produce sampling distributions that are symmetric and bell-shaped, and we will need an alternative way to calculate confidence intervals in these situations.   


```{r, fig.cap="Image from https://openintro-ims.netlify.app/foundations-mathematical"}
knitr::include_graphics("Emp_Rule.png")
```



If we want to use a level of confidence that is different than 95%, we can adjust the value we multiply the standard error by. In general, a standard error confidence interval has the form 

\[
\text{Statistic } \pm m\times \text{Standard Error}, 
\]

where the value of $m$ depends on the desired level of confidence. 

Of course, you might ask why we needed to calculate a confidence interval for the proportion of on-time flights in the first place, since we actually have data on all 20,591 flights in the population and already know the true proportion of on-time arrivals to be 0.608. The answer is that we don't. But, in most real situations, we will only have data from a single sample, not the entire population, and we won't know the true population parameter. We'll be able to build on the ideas of sampling distributions and standard error that we learned about in this section to calculate confidence intervals in those scenarios.  


## Bootstrapping

### Mercury Levels in Florida Lakes

A 2004 study by Lange, T., Royals, H. and Connor, L. examined Mercury accumulation in large-mouth bass, taken from a sample of 53 Florida Lakes. If Mercury accumulation exceeds 0.5 ppm, then there are environmental concerns. In fact, the legal safety limit in Canada is 0.5 ppm, although it is 1 ppm in the United States.


Recall that our data come from a sample of 53 lakes, out of more then 30,000 in the entire state of Florida. 


The mercury levels of the first 10 lakes in the sample are shown in the table below. 


```{r}
data("FloridaLakes")
FloridaLakes <- FloridaLakes %>% rename(Mercury = AvgMercury)
```

```{r}
kable(head(FloridaLakes %>% select(ID, Lake, Mercury), 10))
```

The histogram shows the distribution of mercury levels in the 53 lakes in the sample. Lakes exceeding the US standard of 1 ppm are shown in red.  

```{r}
Lakes_Hist <- ggplot(data=FloridaLakes, aes(x=Mercury)) + 
  geom_histogram(aes(fill=Mercury<=1), color="white", binwidth = 0.1) + 
  ggtitle("Mercury Levels in Sample of 53 Florida Lakes") + 
  xlab("Mercury Level") + ylab("Frequency") + theme_bw()
Lakes_Hist
```

The proportion of lakes with mercury levels exceeding 1 ppm is calculated below. 

```{r}
p_hat <- sum(FloridaLakes$Mercury > 1)/53
p_hat
```


We see that in our sample of 53 lakes, approximately 11% have mercury levels exceeding the US standard of 1 ppm. Suppose we want to estimate the proportion of all Florida Lakes whose mercury level exceeds this standard. As we saw in the previous section, we would not expect the population proportion to exactly match the sample, due to random variability between samples. We can use the sample proportion as an estimate ($\hat{p} = 0.1132$), and construct a confidence interval for the unknown population proportion $p$.

In order to construct the confidence interval, we need to know how much the sample proportion of lakes exceeding 1 ppm $\hat{p}$ could vary between different samples of size 53. That is, we need to know the standard error of $\hat{p}$. In the previous section, we calculated the standard error by taking 10,000 different samples of the same size as ours from the population, calculating the proportion for each sample, and then calculating the standard deviation of the proportions obtained from these 10,000 different samples. This procedure will not work here, however, because unlike the previous example where we really did have data on the entire population of all flights from New York to Chicago, we do not have data on all 30,000+ lakes in Florida. We cannot take a lot of different samples of size 53 from the population of all lakes, and thus, cannot obtain the sampling distribution for the the proportion of lakes exceeding 1 ppm, or estimate the standard error of $\hat{p}$. 



### Bootstrap Sampling

All we have is a single sample of 53 lakes. We need to figure out how much the proportion of lakes with mercury levels exceeding 1 ppm would vary between different samples of size 53, using only the information contained in our one sample.  

To do this, we'll implement a popular simulation-based strategy, known as **bootstrapping**.

Let's assume our sample is representative of all Florida lakes. Then, we'll duplicate the sample many times to create a large set that will look like the population of all Florida Lakes. We can then draw samples of 53 from that large population, and record the mean mercury level for each sample of 53.  

An illustration of the bootstrapping procedure is shown below, using a sample of 12 colored dots, instead of the 53 lakes. 

```{r, echo=FALSE, out.width = '100%'}
knitr::include_graphics("Bootstrap_Idea.png")
```

In fact, duplicating the sample many times and selecting new samples of size $n$ has the same effect as drawing samples of size $n$ from the original sample, by putting the item drawn back in each time, a procedure called **sampling with replacement**. Thus, we can skip the step of copying/pasting the sample many times, and instead draw our samples with replacement. 

This means that in each new sample, some lakes will be drawn multiple times and others not at all. It also ensures that each sample is different, allowing us to estimate variability in the sample mean between the different samples of size 53.   

An illustration of the concept of bootstrapping, using sampling with replacement is shown below.   

```{r, echo=FALSE, out.width = '100%'}
knitr::include_graphics("Bootstrap.png")
```


The variability in sample means in our newly drawn samples is used to approximate the variability in proportion $\hat{p}$ that would occur between different samples of 53 lakes, drawn from the population of all Florida Lakes.   

The point of bootstrapping is to observe how much a statistic (in this case the proportion of lakes with Mercury levels exceeding 1 ppm) varies between bootstrap samples. This can act as an estimate of how much that statistic would vary between different samples of size $n$, drawn from the population. 

The steps of bootstrap sampling can be summarized in the following algorithm. 

**Bootstrap Algorithm**

For an original sample of size $n$: 

1. Take a sample size $n$ by randomly sampling from the original, with replacement. Thus, some observations will show up multiple times, and others not at all. This sample is called a **bootstrap sample**.     

2. Calculate the statistic of interest in the bootstrap sample (in this case $\hat{p}$, the proportion of lakes whose mercury levels exceed 1 ppm).    

3. Repeat steps 1 and 2 many (say 10,000) times, keeping track of the statistic of interest that is calculated in each bootstrap sample. 

4. Look at the distribution of the statistic across bootstrap samples. The variability in this bootstrap distribution can be used to approximate the variability in the sampling distribution for the statistic of interest. 

### Bootstrap Samples of Lakes

The `sample_n()` function samples the specified number rows from a data frame, with or without replacement.  

The lakes in the first sample are shown below. Notice that some lakes occur multiple times, and others not at all. 

**Bootstrap Sample 1**

```{r}
BootstrapSample1 <- sample_n(FloridaLakes, 53, replace=TRUE) %>% arrange(Lake)
BootstrapSample1 %>% select(ID, Lake, Mercury)
```

We calculate the proportion of lakes with mercury levels exceeding 1 ppm in this bootstrap sample. Note that if a lake shows up more than once in the bootstrap sample, then it is counted however many times it shows up. 

```{r}
sum(BootstrapSample1$Mercury > 1) / 53
```

***Bootstrap Sample #2** 

We take a second bootstrap sample. Notice that the lakes chosen and omitted differ from the first sample. 

```{r}
BootstrapSample2 <- sample_n(FloridaLakes, 53, replace=TRUE) %>% arrange(Lake)
BootstrapSample2 %>% select(ID, Lake, Mercury)
```

Proportion exceeding 1 ppm: 

```{r}
sum(BootstrapSample2$Mercury > 1) / 53
```

**Bootstrap Sample #3**

We'll take one more bootstrap sample and calculate the proportion of lakes with mercury levels exceeding 1 ppm. 

```{r}
BootstrapSample3 <- sample_n(FloridaLakes, 53, replace=TRUE) %>% arrange(Lake)
BootstrapSample3 %>% select(ID, Lake, Mercury)
```

Proportion exceeding 1 ppm: 

```{r}
sum(BootstrapSample3$Mercury > 1) / 53
```

### Bootstrap Distribution

Now that we have seen how bootstrap sampling works, we'll take a large number (10,000) different bootstrap samples and examine how the proportion of lakes with mercury levels exceeding 1 ppm varies between samples.   

We'll use a `for-loop` to take many different bootstrap samples and record the observed proportion in a vector called `p_hat_b` 

```{r}
p_hat <- sum(FloridaLakes$Mercury > 1)/53 #calculate sample statistic
Bootstrap_prop <- rep(NA, 10000)   #setup vector to hold bootstrap statistics

for (i in 1:10000){
BootstrapSample <- sample_n(FloridaLakes, 53, replace=TRUE) #take bootstrap sample
Bootstrap_prop[i] <- sum(BootstrapSample$Mercury > 1)/53 # calc. prop exceeding 1
}
Lakes_Bootstrap_Prop <- data.frame(Bootstrap_prop)  #store values in a dataframe
```

The distribution of proportions observed in the 10,000 different bootstrap samples is shown below. This distribution is called the **bootstrap distribution.**

```{r}
Lakes_Bootstrap_Prop_plot <- ggplot(data=Lakes_Bootstrap_Prop, aes(x=Bootstrap_prop)) +  
  geom_histogram(color="white", fill="lightblue") +
  xlab("Prop > 1 in Bootstrap Sample ") + ylab("Frequency") +
  ggtitle("Bootstrap Distribution for Prop. of Lakes Exeeding 1 ppm Hg") + 
  theme(legend.position = "none")
Lakes_Bootstrap_Prop_plot
```

### Bootstrap SE Confidence Interval

We calculate the standard deviation of this bootstrap distribution, which is an estimate of the standard error of $\hat{p}$. 

```{r}
SE_p_hat <- sd(Lakes_Bootstrap_Prop$Bootstrap_prop)
```

Since the bootstrap distribution is roughly symmetric and bell-shaped, we can calculate a 95% confidence interval for the proportion of all Florida lakes with mercury levels exceeding 1 ppm, using bootstrap standard error confidence interval method

\[
\hat{p} \pm 2\times\text{SE}(\hat{p})
\]

```{r}
c(p_hat - 2*SE_p_hat, p_hat + 2*SE_p_hat)
```

We are 95% confident that the proportion of all Florida lakes with mercury levels exceeding 1 ppm is between `r p_hat - 2*SE_p_hat` and `r p_hat + 2*SE_p_hat`. 

The gold bar at the bottom of the bootstrap distribution represents this 95% confidence interval.  

```{r}
Lakes_Bootstrap_Prop_plot + 
  geom_segment(aes(x=p_hat - 2*SE_p_hat,xend=p_hat + 2*SE_p_hat, y=50, yend=50),
               color="gold", size=10, alpha=0.01) 
```

### Bootstrap Distribution vs Sampling Distribution

We stated that the standard error of the bootstrap distribution is meant to give us and estimate of the standard error of the statistic of interest ($\hat{p}$ in this case). We do note, however, that the bootstrap distribution is not the same as the sampling distribution for a statistic illustrated in the previous section. The sampling distribution shows the distribution of values the statistic would take on accross many different samples drawn from the population. As such, it will be centered at the true population parameter ($p$ in this case). The bootstrap distribution, on the other hand, shows us the distribution of values the statistic takes on across different bootstrap samples drawn from the original sample, using replacement. Since it comes entirely from the original sample, rather than the population, it will be centered at the sample statistic ( in this case $\hat{p}$), rather than the unknown $p$. Nevertheless, the amount of variability in a statistic, calculated between different bootstrap samples, is often a reasonable approximation of the amount of variability we would observe in that statistic if we could take many samples of the same size from the entire population. 


## Bootstrap Confidence Interval Example

### Bootstrapping Other Statistics

We've seen how to use bootstrapping to calculate confidence intervals for an unknown population parameter $p$, using an estimate $\hat{p}$, calculated from a sample of size $n$. This procedure can be applied to calculate confidence intervals for a wide range of population parameters, using statistics calculated from a sample.  

For example, we could calculate confidence intervals any of the following parameters, using the corresponding sample statistic.  

| Context | Parameter | Statistic|
|-----------|----------|----------|
| Proportion | $p$ | $\hat{p}$|
| Mean | $\mu$ | $\bar{x}$|
| Standard Deviation | $\sigma$ | $s$ |
| Median | no comon abbreviations |
| Difference in Means | $\mu_2-\mu_1$ | $\bar{x}_2 - \bar{x}_1$ |
| Regression Coefficient | $\beta_j$ | $b_j$ |
| Estimated Regression Response| $\beta_0 + \beta_1x_{i1} + \ldots + \beta_px_{ip}$ | $b_0 + b_1x_{i1} + \ldots + b_px_{ip}$ |

We follow the same algorithm as we did when working with a proportion, and simply calculate whatever statistic we are interested in step 2, in place of $\hat{p}$, as we did previously. 


The bootstrap algorithm is given again, below. 

**Bootstrap Algorithm**

For an original sample of size $n$: 

1. Take a sample of size $n$ by randomly sampling from the original sample with replacement. (Thus some observations will show up multiple times and others not at all.)     

2. Calculate the statistic of interest in the bootstrap sample. 

3. Repeat steps 1 and 2 many (say 10,000) times, keeping track of the statistic of interest that is calculated in each bootstrap sample. 

4. Look at the distribution of the statistic across bootstrap samples. The variability in this bootstrap distribution can be used to approximate the variability in the sampling distribution for the statistic of interest. 


We'll now go through examples, calculating bootstrap confidence intervals for each of the parameters listed above. 

###  CI for Mean

The histogram shows the distribution of mercury levels of the 53 lakes in our sample. The mean and standard deviation in mercury levels for these 53 lakes is shown. 

```{r}
Lakes_Hist <- ggplot(data=FloridaLakes, aes(x=Mercury)) + 
  geom_histogram(color="white", fill="lightblue", binwidth = 0.2) + 
  ggtitle("Mercury Levels in Sample of Florida Lakes") + 
  xlab("Mercury Level") + ylab("Frequency") 
Lakes_Hist
```

We'll calculate the mean and median mercury level for the 53 lakes in the sample. 


```{r}
Lakes_Stats <- FloridaLakes %>% summarize(MeanHg = mean(Mercury), 
                           StDevHG = sd(Mercury),
                           N=n())
kable(Lakes_Stats)
```


We want to calculate a 95% confidence interval for the mean mercury level among all Florida lakes. 
We'll use bootstrapping again, this time using the sample mean, rather than the proportion exceeding 1 ppm, as our statistic of interest. 

**Bootstrap Steps**

1. Take a sample of 53 lakes by randomly sampling from the original sample of 53 lakes, with replacement.

2. Calculate the mean mercury level in the bootstrap sample. 

3. Repeat steps 1 and 2 many (say 10,000) times, keeping track of the mean mercury level in each bootstrap sample. 

4. Look at the distribution of the mean across bootstrap samples. The variability in this bootstrap distribution can be used to approximate the variability in the sampling distribution for the mean mercury level. 

We'll illustrate the procedure on 3 bootstrap samples. 

**Bootstrap Sample 1**

```{r}
BootstrapSample1 <- sample_n(FloridaLakes, 53, replace=TRUE) %>% arrange(Lake)
BootstrapSample1 %>% select(ID, Lake, Mercury)
```

We calculate the mean mercury level among the lakes in the bootstrap sample.    

```{r}
mean(BootstrapSample1$Mercury)
```

**Bootstrap Sample #2** 

```{r}
BootstrapSample2 <- sample_n(FloridaLakes, 53, replace=TRUE) %>% arrange(Lake)
BootstrapSample2 %>% select(ID, Lake, Mercury)
```

Mean Mercury Level: 

```{r}
mean(BootstrapSample2$Mercury)
```

**Bootstrap Sample #3**

```{r}
BootstrapSample3 <- sample_n(FloridaLakes, 53, replace=TRUE) %>% arrange(Lake)
BootstrapSample3 %>% select(ID, Lake, Mercury)
```

Mean Mercury Level: 

```{r}
mean(BootstrapSample3$Mercury)
```


Now, we'll take 10,000 bootstrap samples, and record the mean mercury concentration in each sample.  

```{r}
mean <- mean(FloridaLakes$Mercury)  #calculate sample statistic
Bootstrap_Mean <- rep(NA, 10000) # setup vector to hold bootstrap statistics

for (i in 1:10000){
BootstrapSample <- sample_n(FloridaLakes, 53, replace=TRUE) # take bootstrap sample
Bootstrap_Mean[i] <- mean(BootstrapSample$Mercury) # calculate mean in bootstrap sample
}
Lakes_Bootstrap_Results_Mean <- data.frame(Bootstrap_Mean)  #store results in data frame
```

The bootstrap distribution for the mean mercury level is shown below, along with its standard error. 


```{r}
Lakes_Bootstrap_Mean_Plot <- ggplot(data=Lakes_Bootstrap_Results_Mean, 
                                    aes(x=Bootstrap_Mean)) +  
  geom_histogram(color="white", fill="lightblue") +
  xlab("Mean Mercury in Bootstrap Sample ") + ylab("Frequency") +
  ggtitle("Bootstrap Distribution for Sample Mean in Florida Lakes") + 
  theme(legend.position = "none") 
Lakes_Bootstrap_Mean_Plot 
```

We'll calculate the standard error of the mean. This is a measure of how much the mean varies between samples. 

```{r}
SE_mean <- sd(Lakes_Bootstrap_Results_Mean$Bootstrap_Mean)
SE_mean
```

Notice that the standard error of the mean is much less than the sample standard deviation of 0.527. 

**Interpretations of sample standard deviation and standard error of the mean**    

* The sample standard deviation measures the amount of variability in mercury levels between the 53 individual lakes in our sample.     
* The standard error of the mean measures the amount of variability in sample mean mercury levels between different samples of size 53.    

There is more variability between mercury levels in individual lakes than there is between average mercury levels in different samples of size 53. 

Since the bootstrap distribution is roughly symmetric and bell-shaped, we can use the bootstrap standard error method to calculate an approximate 95% confidence interval for the mean mercury level among all Florida lakes. 

\[
\text{Statistic} \pm 2\times\text{Standard Error}
\]

In this case, the statistic of interest is the sample mean $\bar{x}=0.527$. The confidence interval is 

$$
\begin{aligned}
& \bar{x} \pm 2\times\text{SE}(\bar{x}) \\
& = 0.527 \pm 2\times{0.458}
\end{aligned}
$$

95% Confidence Interval:

```{r}
c(mean - 2*SE_mean, mean + 2*SE_mean) 
```

The 95% confidence interval is shown by the gold bar on the graph of the bootstrap distribution below.  

```{r}
Lakes_Bootstrap_Mean_Plot + 
  geom_segment(aes(x=mean - 2*SE_mean,xend=mean + 2*SE_mean, y=50, yend=50), 
               color="gold", size=10, alpha=0.01) 
```

We are 95% confident that the average mercury level among all Florida lakes is between `r mean - 2*SE_mean` and `r mean + 2*SE_mean` parts per million.  

It is important to note that we are not saying that we are 95% confident that an individual lake lie in this range, or that 95% of all individual lakes lie in this range. We are only saying that we are confident that the *average* mercury level among all lakes lies in this range. A confidence interval is a statement about a population parameter (in this case the average mercury level), rather than about individual lakes in the population. Since there is more variability about individual lakes than overall averages, we'll need to make a wider interval when attempting talking about the mercury level for an individual lake. 


###  CI for Standard Deviation

Now, we'll calculate a confidence interval for the standard deviation in mercury levels among all Florida lakes. Recall that the sample standard deviation ($s$) was: 

```{r}
Sample_SD <- sd(FloridaLakes$Mercury)
Sample_SD
```

We'll use this estimate to calculate a confidence interval for the population standard deviation $\sigma$. 

This time, our statistic of interest is the sample standard deviation $s$. 

**Bootstrap Steps**

1. Take a sample of 53 lakes by randomly sampling from the original sample of 53 lakes, with replacement.

2. Calculate the standard deviation in mercury level in the bootstrap sample. 

3. Repeat steps 1 and 2 many (say 10,000) times, keeping track of the standard deviation mercury level in each bootstrap sample. 

4. Look at the distribution of the standard deviations across bootstrap samples. The variability in this bootstrap distribution can be used to approximate the variability in the sampling distribution for the standard deviation in mercury level. 

We'll illustrate the procedure on 3 bootstrap samples. 

**Bootstrap Sample 1**

```{r}
BootstrapSample1 <- sample_n(FloridaLakes, 53, replace=TRUE) %>% arrange(Lake)
BootstrapSample1 %>% select(ID, Lake, Mercury)
```

We calculate the standard deviation in mercury levels among the lakes in the bootstrap sample.    

```{r}
sd(BootstrapSample1$Mercury)
```

**Bootstrap Sample #2** 

```{r}
BootstrapSample2 <- sample_n(FloridaLakes, 53, replace=TRUE) %>% arrange(Lake)
BootstrapSample2 %>% select(ID, Lake, Mercury)
```

Standard Deviation in Mercury Level: 

```{r}
sd(BootstrapSample2$Mercury)
```

**Bootstrap Sample #3**

```{r}
BootstrapSample3 <- sample_n(FloridaLakes, 53, replace=TRUE) %>% arrange(Lake)
BootstrapSample3 %>% select(ID, Lake, Mercury)
```

Standard Deviation Mercury Level: 

```{r}
sd(BootstrapSample3$Mercury)
```


Now, we'll take 10,000 bootstrap samples, and record the standard deviation in mercury concentration in each sample.  

```{r}
Sample_SD <- sd(FloridaLakes$Mercury)  #calculate sample statistic
Bootstrap_SD <- rep(NA, 10000) # setup vector to hold bootstrap statistics

for (i in 1:10000){
BootstrapSample <- sample_n(FloridaLakes, 53, replace=TRUE) # take bootstrap sample
Bootstrap_SD[i] <- sd(BootstrapSample$Mercury) # calculate standard deviation in bootstrap sample
}
Lakes_Bootstrap_Results_SD <- data.frame(Bootstrap_SD)  #store results in data frame
```

The bootstrap distribution for the mean mercury level is shown below, along with its standard error. 


```{r}
Lakes_Bootstrap_SD_Plot <- ggplot(data=Lakes_Bootstrap_Results_SD, 
                                    aes(x=Bootstrap_SD)) +  
  geom_histogram(color="white", fill="lightblue") +
  xlab("SD in Mercury in Bootstrap Sample ") + ylab("Frequency") +
  ggtitle("Bootstrap Distribution for Sample SD in Florida Lakes") + 
  theme(legend.position = "none") 
Lakes_Bootstrap_SD_Plot 
```

We'll calculate the standard error of the standard deviation. This is a measure of how much the standard deviation varies between samples. 

```{r}
SE_SD <- sd(Lakes_Bootstrap_Results_SD$Bootstrap_SD)
SE_SD
```

Since the bootstrap distribution is roughly symmetric and bell-shaped, we can use the bootstrap standard error method to calculate an approximate 95% confidence interval for the standard deviation in mercury levels among all Florida lakes. 


\[
\text{Statistic} \pm 2\times\text{Standard Error}
\]

In this case, the statistic of interest is the sample standard deviation $s=0.341$. The confidence interval is 

$$
\begin{aligned}
& s \pm 2\times\text{SE}(s) \\
& = 0.341 \pm 2\times{0.029}
\end{aligned}
$$
95% Confidence Interval:

```{r}
c(Sample_SD - 2*SE_SD, Sample_SD + 2*SE_SD        ) 
```

The 95% confidence interval is shown by the gold bar on the graph of the bootstrap distribution below.  

```{r}
Lakes_Bootstrap_SD_Plot + 
  geom_segment(aes(x=Sample_SD - 2*SE_SD,xend=Sample_SD + 2*SE_SD, y=50, yend=50), 
               color="gold", size=10, alpha=0.01) 
```

We are 95% confident that the standard deviation in mercury levels among all Florida lakes is between `r mean - 2*SE_SD` and `r mean + 2*SE_SD` parts per million.  


###  CI for Median     


We already calculated a confidence interval for the mean mercury level among all Florida lakes. We could calculate a bootstrap confidence interval for the median mercury level as well, but since the distribution of mercury levels in the lakes is roughly symmetric, the mean is a reasonable measure of center, and there is not a clear reason for using the median instead. 

When a distribution is skewed or contains large outliers, however, the median is a more robust measure of center than the mean. Recall the distribution of 100 Seattle house prices seen in Chapters 1 and 2. 

```{r}
ggplot(data=Houses, aes(x=price)) + 
  geom_histogram(fill="lightblue", color="white") + 
  ggtitle("Distribution of House Prices") +
  xlab("Price") + 
  ylab("Frequency")
```

These 100 houses are a sample of all houses sold in Seattle in 2014 and 2015, so we can use statistics from our sample to draw conclusions about all houses sold in Seattle in this time period. 

In this subsection, we'll use bootstrapping to calculate a 95% confidence interval for the median price among all houses sold in Seattle in this time period. 

We calculate the sample median price.

```{r}
Sample_Median <- median(Houses$price)
Sample_Median
```


**Bootstrap Steps**

1. Take a sample of 100 houses by randomly sampling from the original sample of 100 houses, with replacement.

2. Calculate the median price in the bootstrap sample. 

3. Repeat steps 1 and 2 many (say 10,000) times, keeping track of the median price in each bootstrap sample. 

4. Look at the distribution of the median price across bootstrap samples. The variability in this bootstrap distribution can be used to approximate the variability in the sampling distribution for the median price. 

We'll illustrate the procedure on 3 bootstrap samples. 

**Bootstrap Sample 1**

```{r}
BootstrapSample1 <- sample_n(Houses, 100, replace=TRUE) %>% arrange(Id)
BootstrapSample1 %>% select(Id, price)
```

We calculate the median price among the houses in the bootstrap sample.    

```{r}
median(BootstrapSample1$price)
```

**Bootstrap Sample #2** 

```{r}
BootstrapSample2 <- sample_n(Houses, 100, replace=TRUE) %>% arrange(Id)
BootstrapSample2 %>% select(Id, price)
```

Median Price: 

```{r}
median(BootstrapSample2$price)
```

**Bootstrap Sample #3**

```{r}
BootstrapSample3 <- sample_n(Houses, 100, replace=TRUE) %>% arrange(Id)
BootstrapSample3 %>% select(Id, price)
```

Median Price: 

```{r}
median(BootstrapSample3$price)
```


Now, we'll take 10,000 bootstrap samples, and record the median price in each sample.  

```{r}
Sample_Med <- median(Houses$price)  #calculate sample median
Bootstrap_Med <- rep(NA, 10000) # setup vector to hold bootstrap statistics

for (i in 1:10000){
BootstrapSample <- sample_n(Houses, 100, replace=TRUE) # take bootstrap sample
Bootstrap_Med[i] <- median(BootstrapSample$price) # calculate standard deviation in bootstrap sample
}
Houses_Bootstrap_Results_Med <- data.frame(Bootstrap_Med)  #store results in data frame
```

The bootstrap distribution for the median price is shown below, along with its standard error. 


```{r}
Houses_Bootstrap_Med_Plot <- ggplot(data=Houses_Bootstrap_Results_Med, 
                                    aes(x=Bootstrap_Med)) +  
  geom_histogram(color="white", fill="lightblue") +
  xlab("Median Price in Bootstrap Sample ") + ylab("Frequency") +
  ggtitle("Bootstrap Distribution for Median Price in Seattle Houses") + 
  theme(legend.position = "none") 
Houses_Bootstrap_Med_Plot 
```

We'll calculate the standard error of the median. This is a measure of how much the median varies between samples. 

```{r}
SE_Med <- sd(Houses_Bootstrap_Results_Med$Bootstrap_Med)
SE_Med
```

The standard error measures the amount of variability in median house price between different samples of size 100. 

Note that this is different than the sample standard deviation, which represents the standard deviation in prices between the 100 different houses in the sample. 


Notice that the bootstrap distribution for the median is not symmetric and bell-shaped. Thus, we cannot be assured that 95% of samples will produce a statistic within two standard errors of the mean, so the standard error confidence interval method is not appropriate here. Instead, we'll calculate a confidence interval by taking the middle 95% of the values in the bootstrap distribution.    

We'll calculate the 0.025 quantile and the 0.975 quantile of this bootstrap distribution. These are the points below which lie 2.5% and 97.5% of the medians in the bootstrap distribution. Thus, the middle 95% of the medians lie between these values. 

```{r}
q.025 <- quantile(Houses_Bootstrap_Results_Med$Bootstrap_Med, 0.025)
q.025
```

```{r}
q.975 <- quantile(Houses_Bootstrap_Results_Med$Bootstrap_Med, 0.975)
q.975 
```

The 95% confidence interval is shown by the gold bar on the graph of the bootstrap distribution below.  

```{r}
Houses_Bootstrap_Med_Plot + 
  geom_segment(aes(x=q.025,xend=q.975, y=50, yend=50), 
               color="gold", size=10, alpha=0.01) 
```

We are 95% confident that the median price among all houses that sold in Seattle between 2014 and 2015 is between `r q.025` and `r q.975` thousand dollars.  


###  CI for Difference in Means

We previously calculated a confidence interval for the average mercury level among all lakes in Florida. 

Now, we'll calculate an interval for the difference in average mercury levels between lakes in Northern Florida, compared to Southern Florida.  


```{r, include=FALSE }
#Location relative to rt. 50
FloridaLakes$Location <- as.factor(c("S","S","N","S","S","N","N","N","N","N","N","S","N","S","N","N","N","N","S","S","N","S","N","S","N","S","N","S","N","N","N","N","N","N","S","N","N","S","S","N","N","N","N","S","N","S","S","S","S","N","N","N","N"))
head(FloridaLakes %>% select(Lake, Mercury, Location))
```

The boxplot shows and table below describe the distribution of mercury levels for lakes in Northern Florida, compared to Southern Florida. 


```{r}
LakesBP <- ggplot(data=FloridaLakes, aes(x=Location, y=Mercury, fill=Location)) + 
  geom_boxplot() +   geom_jitter() + ggtitle("Mercury Levels in Florida Lakes") + 
  xlab("Location") + ylab("Mercury Level") + theme(axis.text.x = element_text(angle = 90)) + coord_flip()
LakesBP
```



```{r}
LakesTable <- FloridaLakes %>% group_by(Location) %>% summarize(MeanHg=mean(Mercury), 
                                                  StDevHg=sd(Mercury), 
                                                  N=n())
LakesTable
```

In our sample of 33 Northern Lakes and 20 Southern Lakes, we saw a difference of 0.27 ppm. We'll calculate a confidence interval to estimate how big or small this difference could be among all Florida lakes. 


We'll use a statistical model to calculate the average mercury levels in Northern and Southern Florida. 

$\widehat{\text{Mercury}} = b_0 +b_1\text{I}_{\text{South}}$


* $b_0$ represents the mean mercury level for lakes in North Florida, and    
* $b_1$ represents the mean difference in mercury level for lakes in South Florida, compared to North Florida    

The estimates for corresponding to the original sample are shown below. 

```{r}
M <- lm(data=FloridaLakes, Mercury~Location)
M
```


Thus, we can obtain a confidence interval for the difference in average mercury levels by fitting a regression model to each of our bootstrap samples and recording the value of the sample statistic $b_1$, which represents this difference. Alternatively, we could calculate the mean from each group separately and subtract. 

When comparing groups, we make one modification in Step #1 of the bootstrap process. Rather than drawing a sample of size $n$ at random, with replacement, we'll draw the same number of observations from each group as were in the original sample. In this case, we had 33 northern lakes, and 20 southern lakes. 

**Bootstrap Steps**

1. Take a sample of 33 northern lakes and 20 southern lakes by randomly sampling from the original sample, with replacement.

2. Fit a regression model with location as the explanatory variable and record the value of $b_1$, representing the difference between the means for each group (South-North). 

3. Repeat steps 1 and 2 many (say 10,000) times, keeping track of the difference in means in each bootstrap sample. 

4. Look at the distribution of the differences in means across bootstrap samples. The variability in this bootstrap distribution can be used to approximate the variability in the sampling distribution for the difference in means between mercury levels in Northern and Southern Florida. 


We'll illustrate the procedure on 3 bootstrap samples. 

**Bootstrap Sample 1**

```{r}
NLakes <- sample_n(FloridaLakes %>% filter(Location=="N"), 33, replace=TRUE)   ## sample 33 northern lakes
SLakes <- sample_n(FloridaLakes %>% filter(Location=="S"), 20, replace=TRUE)   ## sample 20 southern lakes
BootstrapSample1 <- rbind(NLakes, SLakes) %>% arrange(ID) %>% 
  select(ID, Lake, Location, Mercury)   ## combine Northern and Southern Lakes
BootstrapSample1
```

We fit a regression model to the bootstrap sample and calculate the regression coefficients. We're interested in the second coefficient, $b_1$, which represents the mean difference between lakes in Southern and Northern Florida    

```{r}
Mb1 <- lm(data=BootstrapSample1, Mercury ~ Location) ## fit linear model
Mb1
```
```{r}
NLakes <- sample_n(FloridaLakes %>% filter(Location=="N"), 33, replace=TRUE)   ## sample 33 northern lakes
SLakes <- sample_n(FloridaLakes %>% filter(Location=="S"), 20, replace=TRUE)   ## sample 20 southern lakes
BootstrapSample2 <- rbind(NLakes, SLakes) %>% arrange(ID) %>% 
  select(ID, Lake, Location, Mercury)   ## combine Northern and Southern Lakes
BootstrapSample2
```

**Bootstrap Sample 2**


```{r}
Mb2 <- lm(data=BootstrapSample2, Mercury ~ Location) ## fit linear model
Mb2
```

**Bootstrap Sample 3**

```{r}
NLakes <- sample_n(FloridaLakes %>% filter(Location=="N"), 33, replace=TRUE)   ## sample 33 northern lakes
SLakes <- sample_n(FloridaLakes %>% filter(Location=="S"), 20, replace=TRUE)   ## sample 20 southern lakes
BootstrapSample3 <- rbind(NLakes, SLakes) %>% arrange(ID) %>% 
  select(ID, Lake, Location, Mercury)   ## combine Northern and Southern Lakes
BootstrapSample3
```


```{r}
Mb3 <- lm(data=BootstrapSample3, Mercury ~ Location) ## fit linear model
Mb3
```

We'll now take 10,000 different bootstrap samples and look at the bootstrap distribution for $b_1$, the difference in mean mercury levels between lakes in Southern and Northern Florida

```{r}
M <- lm(data=FloridaLakes, Mercury~Location) #fit model to original sample
Sample_b1 <- M$coefficients[2] # record b1 value (second coefficient)
Bootstrap_b1 <- rep(NA, 10000)  #vector to store b1 values

for (i in 1:10000){
NLakes <- sample_n(FloridaLakes %>% filter(Location=="N"), 33, replace=TRUE)   ## sample 33 northern lakes
SLakes <- sample_n(FloridaLakes %>% filter(Location=="S"), 20, replace=TRUE)   ## sample 20 southern lakes
BootstrapSample <- rbind(NLakes, SLakes)   ## combine Northern and Southern Lakes
M <- lm(data=BootstrapSample, Mercury ~ Location) ## fit linear model
Bootstrap_b1[i] <- M$coefficients[2] ## record b1 
}
NS_Lakes_Bootstrap_Results <- data.frame(Bootstrap_b1)  #save results as dataframe
```


The bootstrap distribution for the difference in means, $b_1$, is shown below, along with the standard error for the difference. 


```{r}
NS_Lakes_Bootstrap_Plot_b1 <- ggplot(data=NS_Lakes_Bootstrap_Results, aes(x=Bootstrap_b1)) +  
  geom_histogram(color="white", fill="lightblue") + 
  xlab("Mean Difference (b1) in Bootstrap Sample") + ylab("Frequency") +
  ggtitle("Northern vs Southern Lakes: Bootstrap Distribution for b1") 
NS_Lakes_Bootstrap_Plot_b1
```

Standard Error of the Difference in Means $b_1$

```{r}
SE_b1 <- sd(NS_Lakes_Bootstrap_Results$Bootstrap_b1)
SE_b1
```

The bootstrap distribution is symmetric and bell-shaped, so we can use the standard error method to calculate a 95% confidence interval. 

$$
\begin{aligned}
& b_1 \pm 2\times\text{SE}(b_1) \\
& = 0.271 \pm 2\times{0.095}
\end{aligned}
$$
95% Confidence Interval:

```{r}
c(Sample_b1 - 2*SE_b1, Sample_b1 + 2*SE_b1) 
```

The 95% confidence interval is shown by the gold bar on the graph of the bootstrap distribution below.  

```{r}
NS_Lakes_Bootstrap_Plot_b1 + 
  geom_segment(aes(x=Sample_b1 - 2*SE_b1,xend=Sample_b1 + 2*SE_b1, y=50, yend=50), 
               color="gold", size=10, alpha=0.01) 
```

We are 95% confident that the mean mercury level among all lakes in Southern Florida is between `r Sample_b1 - 2*SE_b1` and `r Sample_b1 + 2*SE_b1` higher than the mean mercury level among all lakes in Northern Florida.  

**Question:** We previously performed a hypothesis test and concluded that there was evidence that mean mercury level was higher for lakes in South Florida than Northern Florida. Is this confidence interval consistent with the result of the hypothesis test? Why or why not?   


###  CI for Regression Slope

Recall that we examined the relationship between mercury levels and pH in Florida lakes.  


```{r}
ggplot(data=FloridaLakes, aes(y=Mercury, x=pH)) + 
  geom_point() + stat_smooth(method="lm", se=FALSE)
```

The regression equation is 

\[
\widehat{\text{Mercury}} = b_0 + b_1\times\text{pH}
\]

Regression estimates $b_0$ and $b_1$ are shown below. 

```{r}
M <- lm(data=FloridaLakes, Mercury~pH)
M
```

* On average, lakes with pH level 0 are expected to have a mercury level of 1.53 ppm.    
* For each one-unit increase in pH, mercury level is expected to decrease by 0.15 ppm.   

These estimates are sample statistics, calculated from our sample of 53 lakes. We can think of our regression equation estimates $b_0$ and $b_1$ as estimates of parameters $\beta_0$ and $\beta_1$, which pertain to the slope and intercept of the regression line pertaining to the entire population of all lakes in Florida. We'll use $b_0$ and $b_1$ to estimate $\beta_0$ and $\beta_1$ in the same way that we used sample proportion $\hat{p}$ to estimate population proportion $p$ and sample mean $\bar{x}$ to estimate population mean $\mu$. 

The intercept, $\beta_0$ has little meaning here, but the slope $\beta_1$ represents the average change in mercury level for each one-unit increase in pH, among all Florida lakes. We'll use bootstrapping to find a confidence interval for this quantity. 

**Bootstrap Steps**

1. Take a sample of 53 lakes by randomly sampling from the original sample, with replacement.

2. Fit a regression model with pH as the explanatory variable and record the value of slope $b_1$.

3. Repeat steps 1 and 2 many (say 10,000) times, keeping track of slope of the regression line for each bootstrap sample.

4. Look at the distribution of the slopes across bootstrap samples. The variability in this bootstrap distribution can be used to approximate the variability in the sampling distribution for the slope relating mercury and pH levels. 


We'll illustrate the procedure on 3 bootstrap samples. 

**Bootstrap Sample 1**

```{r}
BootstrapSample1 <- sample_n(FloridaLakes , 53, replace=TRUE)  %>% arrange(ID) %>% 
  select(ID, Lake, pH, Mercury)   # take bootstrap sample
BootstrapSample1
```

We fit a regression model to the bootstrap sample and calculate the regression coefficients. We're again interested in the second coefficient, $b_1$, which now represents the slope of the regression line. 

```{r}
Mb1 <- lm(data=BootstrapSample1, Mercury ~ pH) # fit linear model
Mb1
```



**Bootstrap Sample 2**


```{r}
BootstrapSample2 <- sample_n(FloridaLakes , 53, replace=TRUE)  %>% arrange(ID) %>% 
  select(ID, Lake, pH, Mercury)
BootstrapSample2
```



```{r}
Mb2 <- lm(data=BootstrapSample2, Mercury ~ pH) # fit linear model
Mb2
```

**Bootstrap Sample 3**

```{r}
BootstrapSample3 <- sample_n(FloridaLakes , 53, replace=TRUE)  %>% arrange(ID) %>% 
  select(ID, Lake, pH, Mercury)
BootstrapSample3
```


```{r}
Mb3 <- lm(data=BootstrapSample3, Mercury ~ pH) # fit linear model
Mb3
```

We'll now take 10,000 different bootstrap samples and look at the bootstrap distribution for $b_1$, the slope of the regression line relating mercury level and pH. 

```{r}
M <- lm(data=FloridaLakes, Mercury~pH) #fit model to original sample
Sample_b1 <- M$coefficients[2] # record b1 value (second coefficient)
Bootstrap_b1 <- rep(NA, 10000)  #vector to store b1 values

for (i in 1:10000){
BootstrapSample <- sample_n(FloridaLakes , 53, replace=TRUE)   #take bootstrap sample
M <- lm(data=BootstrapSample, Mercury ~ pH) # fit linear model
Bootstrap_b1[i] <- M$coefficients[2] # record b1 
}
Lakes_Bootstrap_Slope_Results <- data.frame(Bootstrap_b1)  #save results as dataframe
```


The bootstrap distribution for the slopes, $b_1$, is shown below, along with the standard error for the difference. 


```{r}
Lakes_Bootstrap_Plot_Slope <- ggplot(data=Lakes_Bootstrap_Slope_Results, aes(x=Bootstrap_b1)) +
  geom_histogram(color="white", fill="lightblue") + 
  xlab("Slope in Bootstrap Sample") + ylab("Frequency") +
  ggtitle("Bootstrap Distribution for Slope") 
Lakes_Bootstrap_Plot_Slope
```

Standard Error of the slope $b_1$

```{r}
SE_b1 <- sd(Lakes_Bootstrap_Slope_Results$Bootstrap_b1)
SE_b1
```

The bootstrap distribution is symmetric and bell-shaped, so we can use the standard error method to calculate a 95% confidence interval. 

$$
\begin{aligned}
& b_1 \pm 2\times\text{SE}(b_1) \\
& = -0.1523 \pm 2\times{0.027}
\end{aligned}
$$

95% Confidence Interval:

```{r}
c(Sample_b1 - 2*SE_b1, Sample_b1 + 2*SE_b1) 
```

The 95% confidence interval is shown by the gold bar on the graph of the bootstrap distribution below.  

```{r}
Lakes_Bootstrap_Plot_Slope + 
  geom_segment(aes(x=Sample_b1 - 2*SE_b1,xend=Sample_b1 + 2*SE_b1, y=50, yend=50), 
               color="gold", size=10, alpha=0.01) 
```

We are 95% confident that among all Florida lakes, for each 1 unit increase in pH, mercury level decreases between  `r -1*(Sample_b1 - 2*SE_b1)` and `r -1*(Sample_b1 + 2*SE_b1)`, on average.



###  CI for Regression Response 

In addition to calculating a confidence interval for the slope of the regression line relating mercury and pH levels in a lake, we can also calculate a confidence interval for the average mercury level among all lakes with a given pH. 

We'll calculate a confidence interval for the average mercury level among all lakes with a neutral pH level of 7. 

The regression equation is 

$$
\begin{aligned}
\widehat{\text{Mercury}} & = b_0 + b_1\times\text{pH} \\
& = 1.5309 - 0.1523\times\text{pH}
\end{aligned}
$$

so the expected mercury level among all lakes with $\text{pH} = 7$ is $b_0+7b_1 = 1.5309-0.1523(7)=0.4648$ ppm. 

This quantity is a statistic calculated from a sample of 53 lakes, so we would not expect the average mercury level among all lakes in the population to be exactly equal to 0.4648. Again, we'll use this sample statistic as an estimate of the population parameter, and use bootstrapping to estimate the variability associated with this statistic, in order to make a confidence interval.  

**Bootstrap Steps**

1. Take a sample of 53 lakes by randomly sampling from the original sample, with replacement.

2. Fit a regression model with location as the explanatory variable and record the values of $b_0$ and $b_1$. Use these to calculate $b_0+7b_1$. 

3. Repeat steps 1 and 2 many (say 10,000) times, keeping track of $b_0$ and $b_1$, and calculating $b_0+7b_1$ in each bootstrap sample. 

4. Look at the distribution of the expected response, $b_0 + 7b_1$, across bootstrap samples. The variability in this bootstrap distribution can be used to approximate the variability in the sampling distribution for the expected mercury level among all lakes with pH level of 7. 


We'll illustrate the procedure on 3 bootstrap samples. 

**Bootstrap Sample 1**

```{r}
BootstrapSample1 <- sample_n(FloridaLakes , 53, replace=TRUE)  %>% arrange(ID) %>% 
  select(ID, Lake, pH, Mercury)   # take bootstrap sample
BootstrapSample1
```

We fit a regression model to the bootstrap sample and calculate the regression coefficients. We're interested in the second coefficient, $b_1$, which represents the mean difference between lakes in Southern and Northern Florida    

```{r}
Mb1 <- lm(data=BootstrapSample1, Mercury ~ pH) ## fit linear model
b0 <- Mb1$coefficients[1] # record value of b0 (first coefficient)
b1 <- Mb1$coefficients[2] # record value of b1 (second coefficient)
b0+7*b1 #calculate b0+7*b1
```



**Bootstrap Sample 2**


```{r}
BootstrapSample2 <- sample_n(FloridaLakes , 53, replace=TRUE)  %>% arrange(ID) %>% 
  select(ID, Lake, pH, Mercury)
BootstrapSample2
```



```{r}
Mb2 <- lm(data=BootstrapSample2, Mercury ~ pH) # fit linear model
b0 <- Mb2$coefficients[1] # record value of b0 (first coefficient)
b1 <- Mb2$coefficients[2] # record value of b1 (second coefficient)
b0+7*b1 #calculate b0+7*b1
```

**Bootstrap Sample 3**

```{r}
BootstrapSample3 <- sample_n(FloridaLakes , 53, replace=TRUE)  %>% arrange(ID) %>% 
  select(ID, Lake, pH, Mercury)
BootstrapSample3
```


```{r}
Mb3 <- lm(data=BootstrapSample3, Mercury ~ pH) # fit linear model
b0 <- Mb3$coefficients[1] # record value of b0 (first coefficient)
b1 <- Mb3$coefficients[2] # record value of b1 (second coefficient)
b0+7*b1 #calculate b0+7*b1
```


We'll now take 10,000 different bootstrap samples and record the values of $b_0$, $b_1$, which we'll then use to calculate $b_0+7b_1$.

```{r}
M <- lm(data=FloridaLakes, Mercury~pH) #fit model to original sample
Sample_b0 <- M$coefficients[1] # record b0 value (second coefficient)
Sample_b1 <- M$coefficients[2] # record b1 value (second coefficient)
Sample_Exp7 <- Sample_b0 + 7*Sample_b1 # calculate sample expected mercury when pH=7
Bootstrap_b0 <- rep(NA, 10000)  #vector to store b1 values
Bootstrap_b1 <- rep(NA, 10000)  #vector to store b1 values

for (i in 1:10000){
BootstrapSample <- sample_n(FloridaLakes , 53, replace=TRUE)   #take bootstrap sample
M <- lm(data=BootstrapSample, Mercury ~ pH) # fit linear model
Bootstrap_b0[i] <- M$coefficients[1] # record b0 
Bootstrap_b1[i] <- M$coefficients[2] # record b1 
}

Bootstrap_Exp7 <-  Bootstrap_b0 + 7*Bootstrap_b1 # calcualte expected response for each bootstrap sample

Lakes_Bootstrap_Exp7_Results <- data.frame(Bootstrap_b0, Bootstrap_b1, Bootstrap_Exp7)  #save results as dataframe
```


The bootstrap distribution for the expected mercury level among all lakes with pH level 7, $b_0+7b_1$, is shown below, along with the standard error for this quantity. 


```{r}
Lakes_Bootstrap_Plot_Exp7 <- ggplot(data=Lakes_Bootstrap_Exp7_Results, aes(x=Bootstrap_Exp7)) +  
  geom_histogram(color="white", fill="lightblue") + 
  xlab("Expected Mercury Level in Bootstrap Sample") + ylab("Frequency") +
  ggtitle( "Bootstrap Distribution for Exp. Mercury when pH=7") 
Lakes_Bootstrap_Plot_Exp7
```

Standard Error of the expected response $b_0 + 7b_1$

```{r}
SE_Exp7 <- sd(Lakes_Bootstrap_Exp7_Results$Bootstrap_Exp7)
SE_Exp7
```

Again, the bootstrap distribution is symmetric and bell-shaped, so we can use the standard error method to calculate a 95% confidence interval. 

$$
\begin{aligned}
& b_1 \pm 2\times\text{SE}(b_1) \\
& = 0.4648 \pm 2\times{0.037}
\end{aligned}
$$

95% Confidence Interval:

```{r}
c(Sample_Exp7 - 2*SE_Exp7, Sample_Exp7 + 2*SE_Exp7) 
```

The 95% confidence interval is shown by the gold bar on the graph of the bootstrap distribution below.  

```{r}
Lakes_Bootstrap_Plot_Exp7 + 
  geom_segment(aes(x=Sample_Exp7 - 2*SE_Exp7,xend=Sample_Exp7 + 2*SE_Exp7, y=50, yend=50), 
               color="gold", size=10, alpha=0.01) 
```

We are 95% confident that average mercury level among all Florida lakes with pH level 7 is between `r Sample_Exp7 - 2*SE_Exp7` and `r Sample_Exp7 + 2*SE_Exp7` ppm.  

Again, we are not saying that we think an individual like with a pH level of 7 will lie in this range, only that the average mercury level among all such lakes lies in this range. 


### More CI's in Regression

We saw in the previous two examples how to calculate a confidence interval for the slope of a regression line, and for an expected response in regression. In fact, we can calculate confidence intervals for any function involving regression coefficients $\beta_0, \beta_1, \ldots, \beta_p$, in a similar manner. 

For example, let's consider the model for Seattle house prices that involved square feet, whether or not the house was on the waterfront, and an interaction term between these variables.  

The model is 

\[
\widehat{Price} = b_0 + b_1\times\text{Sq. Ft.} + b_2\times\text{waterfront} + b_3\times\text{Sq.Ft}\times\text{Waterfront}
\]

We fit the model and obtain the parameter estimates shown below. 

```{r}
M <- lm(data=Houses, price~sqft_living + waterfront +
          sqft_living:waterfront) #fit model to original sample
Sample_b0 <- M$coefficients[1] # record b0 value (second coefficient)
Sample_b1 <- M$coefficients[2] # record b1 value (second coefficient)
Sample_b2 <- M$coefficients[3] # record b1 value (second coefficient)
Sample_b3 <- M$coefficients[4] # record b1 value (second coefficient)
M
```



Consider the following quantities that we might be interested in estimating:

1. The expected price of a 2,000 square foot waterfront house.    
2. The expected price of a 1,500 square foot non-waterfront house.   
3. The difference between the expected price of a house 1,800 square foot house on the waterfront, compared to a house the same size that is not on the waterfront.   
4. The difference in the rate of change in house prices for each additional 100 square feet for houses on the waterfront, compared to houses not on the waterfront.   

Each of these quantities can be expressed as a linear function of our regression coefficients $b_0, b_1, b_2, b_3$. We just need to find the appropriate function of the $\b_j$'s, and then calculate a bootstrap confidence interval for that quantity, using the same steps we've seen in the previous examples. 

Substituting into the regression equation, we see that:   

1. The expected price of a 2,000 square foot waterfront house is given by 
\[b_0 + 2000b_1 + b_2 + 2000b_3\]

We calculate this estimate from the model, based on our sample of 100 houses:


```{r}
2000*Sample_b1 +Sample_b2+2000*Sample_b3 # calculate b0+2000b1+b2+2000b3
```

We estimate that the average price of all 2,000 square foot waterfront houses in Seattle is 937 thousand dollars.


2. The expected price of a 1,500 square foot non-waterfront house is given by 
\[b_0 + 1500b_1\]

```{r}
Sample_b0 + 1500*Sample_b1 # calculate b0+1500b1+
```


We estimate that the average price of all 1,500 square foot non-waterfront houses in Seattle is 395 thousand dollars.

3. The difference between the expected price of a house 1,800 square foot house on the waterfront, compared to a house the same size that is not on the waterfront is given by:

$$
\begin{aligned}
& (b_0 + 1800b_1 + b_2 + 1800b_3) - (b_0 + 1800b_1) \\
& = b_2 +1800b_3
\end{aligned}
$$

```{r}
Sample_b2+1800*Sample_b3 # calculate b2+1800b3
```

We estimate that on average a 1,800 square foot house on the waterfront will cost 414 thousand dollars more than a 1,800 square foot house not on the waterfront.  

4. The difference in the rate of change in house prices for each additional 100 square feet for houses on the waterfront, compared to houses not on the waterfront. 

This question is asking about the difference in slopes of the regression lines relating price and square feet for houses on the waterfront, compared to those not on the waterfront. 

For houses on the waterfront, the regression equation is 

\[
\widehat{Price} = (b_0 + b_2) + (b_1 +b_3)\times\text{Sq. Ft.}, 
\]

so the slope is $b_1 + b_3$.  

For houses not on the waterfront, the regression equation is 

\[
\widehat{Price} = b_0  + b_1 \times\text{Sq. Ft.}, 
\]

so the slope is $b_1$.   

These slope pertain to the expected change in price for each additional 1 square foot. So, for a 100-square foot increase, the price of a waterfront house is expected to increase by $100(b_1+b_3)$, compared to an increase of $100b_1$ for a non-waterfront house. Thus, the difference in the rates of change is $100b_3$.

```{r}
100*Sample_b3 # calculate 100b3
```

We estimate that the price of waterfront houses increases by 43 thousand dollars more for each additional 100 square feet than the price of non-waterfront houses. 


These estimates calculated from the sample are statistics, which, like all the other statistics we've seen are likely to vary from the true values of the corresponding population parameters, due to variability between samples. We can use bootstrapping to calculate confidence intervals for the relevant population parameters, using these sample statistics (the functions of $b_j$'s), just as we've done for the other statistics we've seen. 


**Bootstrap Steps**

1. Take a sample of 100 houses by randomly sampling from the original sample, with replacement.

2. Fit a regression model with location as the explanatory variable and record the values of regression coefficients $b_0, b_1, b_2, b_3$. Use these to calculate each of the four desired quantities (i.e. $b_0 + 2000b_1 + b_2 +2000b_3$)  

3. Repeat steps 1 and 2 many (say 10,000) times, keeping track of the regression coefficients and calculating the desired quantities in each bootstrap sample. 

4. Look at the distribution of the quantities of interest, across bootstrap samples. The variability in this bootstrap distribution can be used to approximate the variability in the sampling distribution for each of these quantities.  


We'll illustrate the procedure on 3 bootstrap samples. 

**Bootstrap Sample 1**

We take the first bootstrap sample and fit a model with interaction. For brevity, we won't list out the houses in each of the bootstrap samples, as the idea should be clear by now. Model coefficients are shown below. 

```{r}
BootstrapSample1 <- sample_n(Houses , 100, replace=TRUE)  %>% arrange(Id) %>% 
  select(Id, price, sqft_living, waterfront)   

Mb1 <- lm(data=BootstrapSample1, price ~ sqft_living + waterfront + sqft_living:waterfront) # fit linear model with interaction
b0 <- Mb1$coefficients[1] # record value of b0 (first coefficient)
b1 <- Mb1$coefficients[2] # record value of b1 (second coefficient)
b2 <- Mb1$coefficients[3] # record value of b2 (third coefficient)
b3 <- Mb1$coefficients[4] # record value of b3 (fourth coefficient)
Mb1
```

We calculate each of the four desired quantities.

```{r}
b0+2000*b1 + b2 + 2000*b3
```


```{r}
b0+1500*b1
```

```{r}
b2+1800*b3
```

```{r}
100*b3
```

**Bootstrap Sample 2**


```{r}
BootstrapSample2 <- sample_n(Houses , 100, replace=TRUE)  %>% arrange(Id) %>% 
  select(Id, price, sqft_living, waterfront)   

Mb2 <- lm(data=BootstrapSample2, price ~ sqft_living + waterfront + sqft_living:waterfront) # fit linear model with interaction
b0 <- Mb2$coefficients[1] # record value of b0 (first coefficient)
b1 <- Mb2$coefficients[2] # record value of b1 (second coefficient)
b2 <- Mb2$coefficients[3] # record value of b2 (third coefficient)
b3 <- Mb2$coefficients[4] # record value of b3 (fourth coefficient)
Mb2
```

We calculate each of the four desired quantities.

```{r}
b0+2000*b1 + b2 + 2000*b3
```


```{r}
b0+1500*b1
```

```{r}
b2+1800*b3
```

```{r}
100*b3
```


**Bootstrap Sample 3**

```{r}
BootstrapSample3 <- sample_n(Houses , 100, replace=TRUE)  %>% arrange(Id) %>% 
  select(Id, price, sqft_living, waterfront)   

Mb3 <- lm(data=BootstrapSample3, price ~ sqft_living + waterfront + sqft_living:waterfront) # fit linear model with interaction
b0 <- Mb3$coefficients[1] # record value of b0 (first coefficient)
b1 <- Mb3$coefficients[2] # record value of b1 (second coefficient)
b2 <- Mb3$coefficients[3] # record value of b2 (third coefficient)
b3 <- Mb3$coefficients[4] # record value of b3 (fourth coefficient)
Mb3
```

We calculate each of the four desired quantities.

```{r}
b0+2000*b1 + b2 + 2000*b3
```


```{r}
b0+1500*b1
```

```{r}
b2+1800*b3
```

```{r}
100*b3
```


We'll now take 10,000 different bootstrap samples and record the values of $b_0$, $b_1$, $b_3$, and $b_4$, which we'll then use to calculate each of our four desired quantities.  

```{r}
M <- lm(data=Houses, price~sqft_living + waterfront +
          sqft_living:waterfront) #fit model to original sample
Sample_b0 <- M$coefficients[1] # record b0 value (second coefficient)
Sample_b1 <- M$coefficients[2] # record b1 value (second coefficient)
Sample_b2 <- M$coefficients[3] # record b1 value (second coefficient)
Sample_b3 <- M$coefficients[4] # record b1 value (second coefficient)
Sample_Q1 <- Sample_b0 + 2000*Sample_b1 +Sample_b2+2000*Sample_b3 # calculate b0+2000b1+b2+2000b3
Sample_Q2 <- Sample_b0 + 1500*Sample_b1 # calculate b0+1500b1+
Sample_Q3 <- Sample_b2+1800*Sample_b3 # calculate b2+1800b3
Sample_Q4 <- 100*Sample_b3 # calculate 100b3

Bootstrap_b0 <- rep(NA, 10000)  #vector to store b0 values
Bootstrap_b1 <- rep(NA, 10000)  #vector to store b1 values
Bootstrap_b2 <- rep(NA, 10000)  #vector to store b2 values
Bootstrap_b3 <- rep(NA, 10000)  #vector to store b3 values


for (i in 1:10000){
BootstrapSample <- sample_n(Houses, 1000, replace=TRUE)   #take bootstrap sample
Mb <- lm(data=BootstrapSample, price ~ sqft_living + 
           waterfront + sqft_living:waterfront) # fit linear model with interaction
Bootstrap_b0[i] <- Mb$coefficients[1] # record value of b0 (first coefficient)
Bootstrap_b1[i] <- Mb$coefficients[2] # record value of b1 (second coefficient)
Bootstrap_b2[i] <- Mb$coefficients[3] # record value of b2 (third coefficient)
Bootstrap_b3[i] <- Mb$coefficients[4] # record value of b3 (fourth coefficient)
}

Bootstrap_Q1 <-  Bootstrap_b0 + 2000*Bootstrap_b1 + Bootstrap_b2 + 2000*Bootstrap_b3
Bootstrap_Q2 <-  Bootstrap_b0 + 1500*Bootstrap_b1 
Bootstrap_Q3 <-  Bootstrap_b2 + 1800*Bootstrap_b3
Bootstrap_Q4 <-  100*Bootstrap_b3

Houses_Bootstrap_Results <- data.frame(Bootstrap_b0, Bootstrap_b1, Bootstrap_b2, Bootstrap_b3, Bootstrap_Q1, Bootstrap_Q2 , Bootstrap_Q3 , Bootstrap_Q4)  #save results as dataframe
```

**Bootstrap Distribution for b_0 + 2000b_1 + b_2 + 2000b_3**

```{r}
Houses_Bootstrap_Plot_Q1 <- ggplot(data=Houses_Bootstrap_Results, 
                                   aes(x=Bootstrap_Q1)) +  
  geom_histogram(color="white", fill="lightblue") + 
  xlab("Expected Price of 2000 Sq. Ft. Waterfront House") + ylab("Frequency") +
  ggtitle( "Bootstrap Distribution b0+2000b1+b2+2000b3") 
Houses_Bootstrap_Plot_Q1
```

Standard Error:

```{r}
SE_Q1 <- sd(Houses_Bootstrap_Results$Bootstrap_Q1)
SE_Q1
```

The bootstrap distribution is symmetric and bell-shaped, so we can use the standard error method to calculate a 95% confidence interval. 


95% Confidence Interval:

```{r}
c(Sample_Q1 - 2*SE_Q1, Sample_Q1 + 2*SE_Q1) 
```

The 95% confidence interval is shown by the gold bar on the graph of the bootstrap distribution below.  

```{r}
Houses_Bootstrap_Plot_Q1 + 
  geom_segment(aes(x=Sample_Q1 - 2*SE_Q1,xend=Sample_Q1 + 2*SE_Q1, y=50, yend=50), 
               color="gold", size=10, alpha=0.01) 
```

We are 95% confident that average price among all 2,000 square foot Seattle waterfront houses  is between `r Sample_Q1 - 2*SE_Q1` and `r Sample_Q1 + 2*SE_Q1` thousand dollars.  

**Bootstrap Distribution for b_0 + 1500b_1**

```{r}
Houses_Bootstrap_Plot_Q2 <- ggplot(data=Houses_Bootstrap_Results, 
                                   aes(x=Bootstrap_Q2)) +  
  geom_histogram(color="white", fill="lightblue") + 
  xlab("Expected Price of 1500 Sq. Ft. Non-Waterfront House") + ylab("Frequency") +
  ggtitle( "Bootstrap Distribution b0+1500b1") 
Houses_Bootstrap_Plot_Q2
```

Standard Error:

```{r}
SE_Q2 <- sd(Houses_Bootstrap_Results$Bootstrap_Q2)
SE_Q2
```

The bootstrap distribution is symmetric and bell-shaped, so we can use the standard error method to calculate a 95% confidence interval. 


95% Confidence Interval:

```{r}
c(Sample_Q2 - 2*SE_Q2, Sample_Q2 + 2*SE_Q2) 
```

The 95% confidence interval is shown by the gold bar on the graph of the bootstrap distribution below.  

```{r}
Houses_Bootstrap_Plot_Q2 + 
  geom_segment(aes(x=Sample_Q2 - 2*SE_Q2,xend=Sample_Q2 + 2*SE_Q2, y=50, yend=50), 
               color="gold", size=10, alpha=0.01) 
```

We are 95% confident that average price among all 1,500 square foot Seattle non-waterfront houses  is between `r Sample_Q2 - 2*SE_Q2` and `r Sample_Q2 + 2*SE_Q2` thousand dollars.  

**Bootstrap Distribution for b_2 + 1800b_3**

```{r}
Houses_Bootstrap_Plot_Q3 <- ggplot(data=Houses_Bootstrap_Results, 
                                   aes(x=Bootstrap_Q3)) +  
  geom_histogram(color="white", fill="lightblue") + 
  xlab("Expected Price Difference WF vs NWF for 1800 sq. Ft. House") + ylab("Frequency") +
  ggtitle( "Bootstrap Distribution b2+1800b3") 
Houses_Bootstrap_Plot_Q3
```

Standard Error:

```{r}
SE_Q3 <- sd(Houses_Bootstrap_Results$Bootstrap_Q3)
SE_Q3
```

The bootstrap distribution is symmetric and bell-shaped, so we can use the standard error method to calculate a 95% confidence interval. 


95% Confidence Interval:

```{r}
c(Sample_Q3 - 2*SE_Q3, Sample_Q3 + 2*SE_Q3) 
```

The 95% confidence interval is shown by the gold bar on the graph of the bootstrap distribution below.  

```{r}
Houses_Bootstrap_Plot_Q3 + 
  geom_segment(aes(x=Sample_Q3 - 2*SE_Q3,xend=Sample_Q3 + 2*SE_Q3, y=50, yend=50), 
               color="gold", size=10, alpha=0.01) 
```

We are 95% confident that the average price among all 1800 square feet waterfront houses in Seattle is between  `r Sample_Q3 - 2*SE_Q3` and `r Sample_Q3 + 2*SE_Q3` thousand dollars more than the average price among all non-waterfront houses of the same size.   



**Bootstrap Distribution for 100b_3**

```{r}
Houses_Bootstrap_Plot_Q4 <- ggplot(data=Houses_Bootstrap_Results, 
                                   aes(x=Bootstrap_Q4)) +  
  geom_histogram(color="white", fill="lightblue") + 
  xlab("Expected Difference per 100 square feet") + ylab("Frequency") +
  ggtitle( "Bootstrap Distribution 100b3") 
Houses_Bootstrap_Plot_Q4
```

Standard Error:

```{r}
SE_Q4 <- sd(Houses_Bootstrap_Results$Bootstrap_Q4)
SE_Q4
```

The bootstrap distribution is symmetric and bell-shaped, so we can use the standard error method to calculate a 95% confidence interval. 


95% Confidence Interval:

```{r}
c(Sample_Q4 - 2*SE_Q4, Sample_Q4 + 2*SE_Q4) 
```

The 95% confidence interval is shown by the gold bar on the graph of the bootstrap distribution below.  

```{r}
Houses_Bootstrap_Plot_Q4 + 
  geom_segment(aes(x=Sample_Q4 - 2*SE_Q4,xend=Sample_Q4 + 2*SE_Q4, y=50, yend=50), 
               color="gold", size=10, alpha=0.01) 
```

We are 95% confident that for each 100 square foot increase, the average price among all waterfront houses increases by between  `r Sample_Q4 - 2*SE_Q4` and `r Sample_Q4 + 2*SE_Q4` thousand dollars more than the increase in average price among all non-waterfront.   

##  Bootstrapping Cautions

